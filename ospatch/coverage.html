
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/GoogleCloudPlatform/osconfig/ospatch/apt_upgrade.go (0.0%)</option>
				
				<option value="file1">github.com/GoogleCloudPlatform/osconfig/ospatch/exec_step.go (0.0%)</option>
				
				<option value="file2">github.com/GoogleCloudPlatform/osconfig/ospatch/exec_step_linux.go (0.0%)</option>
				
				<option value="file3">github.com/GoogleCloudPlatform/osconfig/ospatch/googet_update.go (0.0%)</option>
				
				<option value="file4">github.com/GoogleCloudPlatform/osconfig/ospatch/patch_run.go (2.3%)</option>
				
				<option value="file5">github.com/GoogleCloudPlatform/osconfig/ospatch/patch_state.go (84.9%)</option>
				
				<option value="file6">github.com/GoogleCloudPlatform/osconfig/ospatch/runner.go (0.0%)</option>
				
				<option value="file7">github.com/GoogleCloudPlatform/osconfig/ospatch/system_linux.go (0.0%)</option>
				
				<option value="file8">github.com/GoogleCloudPlatform/osconfig/ospatch/updates.go (65.8%)</option>
				
				<option value="file9">github.com/GoogleCloudPlatform/osconfig/ospatch/updates_linux.go (0.0%)</option>
				
				<option value="file10">github.com/GoogleCloudPlatform/osconfig/ospatch/watcher.go (63.0%)</option>
				
				<option value="file11">github.com/GoogleCloudPlatform/osconfig/ospatch/yum_update.go (0.0%)</option>
				
				<option value="file12">github.com/GoogleCloudPlatform/osconfig/ospatch/zypper_patch.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">//  Copyright 2019 Google Inc. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ospatch

import (
        "fmt"
        "os"
        "os/exec"
)

const aptGet = "/usr/bin/apt-get"

var (
        aptGetUpdateArgs      = []string{"update"}
        aptGetUpgradeArgs     = []string{"upgrade", "-y"}
        aptGetFullUpgradeArgs = []string{"full-upgrade", "-y"}
        aptGetDistUpgradeArgs = []string{"dist-upgrade", "-y"}
)

type aptGetUpgradeType int

const (
        aptGetUpgrade aptGetUpgradeType = iota
        // AptGetDistUpgrade specifies apt-get dist-upgrade should be run.
        AptGetDistUpgrade
        // AptGetFullUpgrade specifies apt-get full-upgrade should be run.
        AptGetFullUpgrade
)

type aptGetUpgradeOpts struct {
        upgradeType aptGetUpgradeType
        runner      func(cmd *exec.Cmd) ([]byte, error)
}

// AptGetUpgradeOption is an option for apt-get update.
type AptGetUpgradeOption func(*aptGetUpgradeOpts)

// AptGetUpgradeType returns a AptGetUpgradeOption that specifies upgrade type.
func AptGetUpgradeType(upgradeType aptGetUpgradeType) AptGetUpgradeOption <span class="cov0" title="0">{
        return func(args *aptGetUpgradeOpts) </span><span class="cov0" title="0">{
                args.upgradeType = upgradeType
        }</span>
}

// AptGetUpgradeRunner returns a AptGetUpgradeOption that specifies the runner.
func AptGetUpgradeRunner(runner func(cmd *exec.Cmd) ([]byte, error)) AptGetUpgradeOption <span class="cov0" title="0">{
        return func(args *aptGetUpgradeOpts) </span><span class="cov0" title="0">{
                args.runner = runner
        }</span>
}

// RunAptGetUpgrade runs apt-get upgrade.
func RunAptGetUpgrade(opts ...AptGetUpgradeOption) error <span class="cov0" title="0">{
        aptOpts := &amp;aptGetUpgradeOpts{
                upgradeType: aptGetUpgrade,
                runner:      defaultRunner,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(aptOpts)
        }</span>

        <span class="cov0" title="0">if _, err := aptOpts.runner(exec.Command(aptGet, aptGetUpdateArgs...)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var args []string
        switch aptOpts.upgradeType </span>{
        case aptGetUpgrade:<span class="cov0" title="0">
                args = aptGetUpgradeArgs</span>
        case AptGetDistUpgrade:<span class="cov0" title="0">
                args = aptGetDistUpgradeArgs</span>
        case AptGetFullUpgrade:<span class="cov0" title="0">
                args = aptGetFullUpgradeArgs</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown upgrade type: %q", aptOpts.upgradeType)</span>
        }

        <span class="cov0" title="0">upgrade := exec.Command(aptGet, args...)
        upgrade.Env = append(os.Environ(),
                "DEBIAN_FRONTEND=noninteractive",
        )
        if _, err := aptOpts.runner(upgrade); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">//  Copyright 2019 Google Inc. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ospatch

import (
        "context"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path"
        "path/filepath"

        osconfigpb "github.com/GoogleCloudPlatform/osconfig/_internal/gapi-cloud-osconfig-go/google.golang.org/genproto/googleapis/cloud/osconfig/v1alpha2"
        "github.com/GoogleCloudPlatform/osconfig/common"
)

func getExecutablePath(ctx context.Context, logger *common.Logger, stepConfig *osconfigpb.ExecStepConfig) (string, error) <span class="cov0" title="0">{
        if gcsObject := stepConfig.GetGcsObject(); gcsObject != nil </span><span class="cov0" title="0">{
                var reader io.ReadCloser
                reader, err := common.FetchWithGCS(ctx, gcsObject.GetBucket(), gcsObject.GetObject(), gcsObject.GetGenerationNumber())
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("error reading GCS object: %s", err)
                }</span>
                <span class="cov0" title="0">defer reader.Close()
                logger.Debugf("Fetched GCS object bucket %s object %s generation number %d", gcsObject.GetBucket(), gcsObject.GetObject(), gcsObject.GetGenerationNumber())

                localPath := filepath.Join(os.TempDir(), path.Base(gcsObject.GetObject()))
                if err := downloadFile(logger, reader, localPath); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return localPath, nil</span>
        }

        <span class="cov0" title="0">return stepConfig.GetLocalPath(), nil</span>
}

func executeCommand(logger *common.Logger, path string, exitCodes []int32, args ...string) error <span class="cov0" title="0">{
        logger.Debugf("Running command %s with args %s", path, args)
        cmdObj := exec.Command(path, args...)

        stdoutStderr, err := cmdObj.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                        allowedCodes := append(exitCodes, 0)
                        for _, code := range allowedCodes </span><span class="cov0" title="0">{
                                if int32(exitErr.ExitCode()) == code </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                        }
                }
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">logger.Infof("%s\n", stdoutStderr)
        return nil</span>
}

func downloadFile(logger *common.Logger, reader io.ReadCloser, localPath string) error <span class="cov0" title="0">{
        if err := common.DownloadStream(reader, "", localPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error downloading GCS object: %s", err)
        }</span>
        <span class="cov0" title="0">if err := os.Chmod(localPath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error making file executable: %s", err)
        }</span>
        <span class="cov0" title="0">logger.Debugf("Downloaded to local path %s", localPath)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">//  Copyright 2018 Google Inc. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ospatch

import (
        "context"
        "fmt"
        "os"

        osconfigpb "github.com/GoogleCloudPlatform/osconfig/_internal/gapi-cloud-osconfig-go/google.golang.org/genproto/googleapis/cloud/osconfig/v1alpha2"
        "github.com/GoogleCloudPlatform/osconfig/common"
)

func (r *patchRun) execPreStep() error <span class="cov0" title="0">{
        logger := &amp;common.Logger{Debugf: r.debugf, Infof: r.infof, Warningf: r.warningf, Errorf: r.errorf, Fatalf: nil}
        return execStep(r.ctx, logger, r.Job.GetPatchConfig().GetPreStep().GetLinuxExecStepConfig())
}</span>

func (r *patchRun) execPostStep() error <span class="cov0" title="0">{
        logger := &amp;common.Logger{Debugf: r.debugf, Infof: r.infof, Warningf: r.warningf, Errorf: r.errorf, Fatalf: nil}
        return execStep(r.ctx, logger, r.Job.GetPatchConfig().GetPostStep().GetLinuxExecStepConfig())
}</span>

func execStep(ctx context.Context, logger *common.Logger, stepConfig *osconfigpb.ExecStepConfig) error <span class="cov0" title="0">{
        if stepConfig != nil </span><span class="cov0" title="0">{
                localPath, err := getExecutablePath(ctx, logger, stepConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting executable path: %v", err)
                }</span>

                <span class="cov0" title="0">codes := stepConfig.GetAllowedSuccessCodes()

                switch stepConfig.GetInterpreter() </span>{
                case osconfigpb.ExecStepConfig_INTERPRETER_UNSPECIFIED:<span class="cov0" title="0">
                        err = executeCommand(logger, localPath, codes)</span>
                case osconfigpb.ExecStepConfig_SHELL:<span class="cov0" title="0">
                        err = executeCommand(logger, "/bin/sh", codes, localPath)</span>
                case osconfigpb.ExecStepConfig_POWERSHELL:<span class="cov0" title="0">
                        err = fmt.Errorf("interpreter POWERSHELL cannot be used on non-Windows system")</span>
                default:<span class="cov0" title="0">
                        err = fmt.Errorf("invalid interpreter %q", stepConfig.GetInterpreter())</span>
                }

                <span class="cov0" title="0">if gcsObject := stepConfig.GetGcsObject(); gcsObject != nil </span><span class="cov0" title="0">{
                        if err := os.Remove(localPath); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("error removing downloaded file %s", err)
                        }</span>
                }

                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">//  Copyright 2019 Google Inc. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ospatch

import (
        "os"
        "os/exec"
        "path/filepath"
)

var (
        googet = filepath.Join(os.Getenv("GooGetRoot"), "googet.exe")

        googetUpdateArgs = []string{"-noconfirm", "update"}
)

type googetUpdateOpts struct {
        runner func(cmd *exec.Cmd) ([]byte, error)
}

// GooGetUpdateOption is an option for apt-get update.
type GooGetUpdateOption func(*googetUpdateOpts)

// GooGetUpdateRunner returns a GooGetUpdateOption that specifies the runner.
func GooGetUpdateRunner(runner func(cmd *exec.Cmd) ([]byte, error)) GooGetUpdateOption <span class="cov0" title="0">{
        return func(args *googetUpdateOpts) </span><span class="cov0" title="0">{
                args.runner = runner
        }</span>
}

// RunGooGetUpdate runs googet update.
func RunGooGetUpdate(opts ...GooGetUpdateOption) error <span class="cov0" title="0">{
        googetOpts := &amp;googetUpdateOpts{
                runner: defaultRunner,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(googetOpts)
        }</span>

        <span class="cov0" title="0">if _, err := googetOpts.runner(exec.Command(googet, googetUpdateArgs...)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">//  Copyright 2018 Google Inc. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ospatch

import (
        "context"
        "errors"
        "fmt"
        "math"
        "math/rand"
        "time"

        "cloud.google.com/go/compute/metadata"
        "github.com/GoogleCloudPlatform/guest-logging-go/logger"
        osconfig "github.com/GoogleCloudPlatform/osconfig/_internal/gapi-cloud-osconfig-go/cloud.google.com/go/osconfig/apiv1alpha2"
        "github.com/GoogleCloudPlatform/osconfig/common"
        "github.com/GoogleCloudPlatform/osconfig/config"
        "github.com/GoogleCloudPlatform/osconfig/inventory"
        "github.com/GoogleCloudPlatform/osconfig/tasker"
        "github.com/golang/protobuf/jsonpb"
        "google.golang.org/api/option"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        osconfigpb "github.com/GoogleCloudPlatform/osconfig/_internal/gapi-cloud-osconfig-go/google.golang.org/genproto/googleapis/cloud/osconfig/v1alpha2"
)

type patchStep string

const (
        prePatch  = "PrePatch"
        patching  = "Patching"
        postPatch = "PostPatch"
)

var (
        cancelC chan struct{}
)

func initPatch(ctx context.Context) <span class="cov0" title="0">{
        cancelC = make(chan struct{})
        disableAutoUpdates()
        go Run(ctx, cancelC)
        // Sleep just long enough for Run to register any pending patches.
        // TODO: Find a cleaner way to ensure any pending patch runs start before
        // other tasks immediately after startup.
        time.Sleep(1 * time.Second)
}</span>

// Configure manages the background patch service.
func Configure(ctx context.Context) <span class="cov0" title="0">{
        select </span>{
        case _, ok := &lt;-cancelC:<span class="cov0" title="0">
                if !ok &amp;&amp; config.OSPatchEnabled() </span><span class="cov0" title="0">{
                        // Patch currently stopped, reenable.
                        logger.Debugf("Enabling OSPatch")
                        initPatch(ctx)
                }</span> else<span class="cov0" title="0"> if ok &amp;&amp; !config.OSPatchEnabled() </span><span class="cov0" title="0">{
                        // This should never happen as nothing should be sending on this
                        // channel.
                        logger.Errorf("Someone sent on the cancelC channel, this should not have happened")
                        close(cancelC)
                }</span>
        default:<span class="cov0" title="0">
                if cancelC == nil &amp;&amp; config.OSPatchEnabled() </span><span class="cov0" title="0">{
                        // initPatch has not run yet.
                        logger.Debugf("Enabling OSPatch")
                        initPatch(ctx)
                }</span> else<span class="cov0" title="0"> if cancelC != nil &amp;&amp; !config.OSPatchEnabled() </span><span class="cov0" title="0">{
                        // Patch currently running, we need to stop it.
                        logger.Debugf("Disabling OSPatch")
                        close(cancelC)
                }</span>
        }
}

// Run runs patching as a single blocking agent, use cancel to cancel.
func Run(ctx context.Context, cancel &lt;-chan struct{}) <span class="cov0" title="0">{
        logger.Debugf("Running OSPatch background task.")

        if err := loadState(config.PatchStateFile()); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("loadState error: %v", err)
        }</span>

        <span class="cov0" title="0">liveState.RLock()
        for _, pr := range liveState.PatchRuns </span><span class="cov0" title="0">{
                pr.ctx = ctx
                go tasker.Enqueue("Run patch", pr.runPatch)
        }</span>
        <span class="cov0" title="0">liveState.RUnlock()

        watcher(ctx, cancel, ackPatch)
        logger.Debugf("OSPatch background task stopping.")</span>
}

type patchRun struct {
        ctx    context.Context
        client *osconfig.Client

        Job         *patchJob
        StartedAt   time.Time `json:",omitempty"`
        PatchStep   patchStep `json:",omitempty"`
        RebootCount int
        LogLabels   map[string]string `json:",omitempty"`
        // TODO add Attempts and track number of retries with backoff, jitter, etc.
}

func (r *patchRun) debugf(format string, v ...interface{}) <span class="cov0" title="0">{
        logger.Log(logger.LogEntry{Message: fmt.Sprintf(format, v...), Severity: logger.Debug, Labels: r.LogLabels})
}</span>

func (r *patchRun) infof(format string, v ...interface{}) <span class="cov0" title="0">{
        logger.Log(logger.LogEntry{Message: fmt.Sprintf(format, v...), Severity: logger.Info, Labels: r.LogLabels})
}</span>

func (r *patchRun) warningf(format string, v ...interface{}) <span class="cov0" title="0">{
        logger.Log(logger.LogEntry{Message: fmt.Sprintf(format, v...), Severity: logger.Warning, Labels: r.LogLabels})
}</span>

func (r *patchRun) errorf(format string, v ...interface{}) <span class="cov0" title="0">{
        logger.Log(logger.LogEntry{Message: fmt.Sprintf(format, v...), Severity: logger.Error, Labels: r.LogLabels})
}</span>

type patchJob struct {
        *osconfigpb.ReportPatchJobInstanceDetailsResponse
}

// MarshalJSON marshals a patchConfig using jsonpb.
func (j *patchJob) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        m := jsonpb.Marshaler{}
        s, err := m.MarshalToString(j)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return []byte(s), nil</span>
}

// UnmarshalJSON unmarshals a patchConfig using jsonpb.
func (j *patchJob) UnmarshalJSON(b []byte) error <span class="cov8" title="1">{
        return jsonpb.UnmarshalString(string(b), j)
}</span>

func (r *patchRun) close() <span class="cov0" title="0">{
        if r.client != nil </span><span class="cov0" title="0">{
                r.client.Close()
        }</span>
}

func (r *patchRun) setStep(step patchStep) error <span class="cov0" title="0">{
        r.PatchStep = step
        if err := saveState(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error saving state: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *patchRun) handleErrorState(msg string, err error) <span class="cov0" title="0">{
        if err == errServerCancel </span><span class="cov0" title="0">{
                r.reportCanceledState()
        }</span> else<span class="cov0" title="0"> {
                r.reportFailedState(msg)
        }</span>
}

func (r *patchRun) reportFailedState(msg string) <span class="cov0" title="0">{
        r.errorf(msg)
        if err := r.reportPatchDetails(osconfigpb.Instance_FAILED, 0, msg); err != nil </span><span class="cov0" title="0">{
                r.errorf("Failed to report patch failure: %v", err)
        }</span>
}

func (r *patchRun) reportCanceledState() <span class="cov0" title="0">{
        r.infof("Canceling patch execution for PatchJob %q: %s", r.Job.GetPatchJob(), errServerCancel)
        if err := r.reportPatchDetails(osconfigpb.Instance_FAILED, 0, errServerCancel.Error()); err != nil </span><span class="cov0" title="0">{
                r.errorf("Failed to report patch cancelation: %v", err)
        }</span>
}

var errServerCancel = errors.New("service marked PatchJob as completed")

func (r *patchRun) reportContinuingState(patchState osconfigpb.Instance_PatchState) error <span class="cov0" title="0">{
        if err := r.reportPatchDetails(patchState, 0, ""); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reporting state %s: %v", patchState, err)
        }</span>
        <span class="cov0" title="0">if r.Job.GetPatchJobState() == osconfigpb.ReportPatchJobInstanceDetailsResponse_COMPLETED </span><span class="cov0" title="0">{
                return errServerCancel
        }</span>
        <span class="cov0" title="0">return saveState()</span>
}

func (r *patchRun) complete() <span class="cov0" title="0">{
        liveState.removePatchRun(r)
        liveState.jobComplete(r.Job.GetPatchJob())
        if err := saveState(); err != nil </span><span class="cov0" title="0">{
                r.errorf("Error saving state: %v", err)
        }</span>
        <span class="cov0" title="0">r.close()</span>
}

// TODO: Add MaxRebootCount so we don't loop endlessly.

func (r *patchRun) prePatchReboot() error <span class="cov0" title="0">{
        return r.rebootIfNeeded(true)
}</span>

func (r *patchRun) postPatchReboot() error <span class="cov0" title="0">{
        return r.rebootIfNeeded(false)
}</span>

func (r *patchRun) rebootIfNeeded(prePatch bool) error <span class="cov0" title="0">{
        var reboot bool
        var err error
        if r.Job.GetPatchConfig().GetRebootConfig() == osconfigpb.PatchConfig_ALWAYS &amp;&amp; !prePatch &amp;&amp; r.RebootCount == 0 </span><span class="cov0" title="0">{
                reboot = true
                r.infof("PatchConfig RebootConfig set to %s.", osconfigpb.PatchConfig_ALWAYS)
        }</span> else<span class="cov0" title="0"> {
                reboot, err = r.systemRebootRequired()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error checking if a system reboot is required: %v", err)
                }</span>
                <span class="cov0" title="0">if reboot </span><span class="cov0" title="0">{
                        r.infof("System indicates a reboot is required.")
                }</span> else<span class="cov0" title="0"> {
                        r.infof("System indicates a reboot is not required.")
                }</span>
        }

        <span class="cov0" title="0">if !reboot </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if r.Job.GetPatchConfig().GetRebootConfig() == osconfigpb.PatchConfig_NEVER </span><span class="cov0" title="0">{
                r.infof("Skipping reboot because of PatchConfig RebootConfig set to %s.", osconfigpb.PatchConfig_NEVER)
                return nil
        }</span>

        <span class="cov0" title="0">if err := r.reportContinuingState(osconfigpb.Instance_REBOOTING); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if r.Job.GetDryRun() </span><span class="cov0" title="0">{
                r.infof("Dry run - not rebooting for patch job '%s'", r.Job.GetPatchJob())
                return nil
        }</span>

        <span class="cov0" title="0">r.RebootCount++
        saveState()
        if err := rebootSystem(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reboot system: %v", err)
        }</span>

        // Reboot can take a bit, pause here so other activities don't start.
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                r.debugf("Waiting for system reboot.")
                time.Sleep(1 * time.Minute)
        }</span>
}

func (r *patchRun) createClient() error <span class="cov0" title="0">{
        if r.client == nil </span><span class="cov0" title="0">{
                var err error
                r.debugf("Creating new OSConfig client.")
                r.client, err = osconfig.NewClient(r.ctx, option.WithEndpoint(config.SvcEndpoint()), option.WithCredentialsFile(config.OAuthPath()))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("osconfig.NewClient Error: %v", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

/**
 * Runs a patch from start to finish. Sometimes this happens in a single invocation. Other times
 * we need to handle the following edge cases:
 * - The watcher has initiated this multiple times for the same patch job.
 * - We have a saved state and are continuing after a reboot.
 * - An error occurred and we do another attempt starting where we last failed.
 * - The process was unexpectedly restarted and we are continuing from where we left off.
 */
func (r *patchRun) runPatch() <span class="cov0" title="0">{
        r.infof("Beginning patch job %s.", r.Job.GetPatchJob())
        if err := r.createClient(); err != nil </span><span class="cov0" title="0">{
                r.errorf("Error creating osconfig client: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                r.complete()
                if config.OSInventoryEnabled() </span><span class="cov0" title="0">{
                        go inventory.Run()
                }</span>
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                r.debugf("Running PatchStep %q.", r.PatchStep)
                switch r.PatchStep </span>{
                default:<span class="cov0" title="0">
                        r.reportFailedState(fmt.Sprintf("unknown step: %q", r.PatchStep))
                        return</span>
                case prePatch:<span class="cov0" title="0">
                        r.StartedAt = time.Now()
                        if err := r.setStep(patching); err != nil </span><span class="cov0" title="0">{
                                r.reportFailedState(fmt.Sprintf("Error saving agent step: %v", err))
                        }</span>
                        <span class="cov0" title="0">if err := r.reportContinuingState(osconfigpb.Instance_STARTED); err != nil </span><span class="cov0" title="0">{
                                r.handleErrorState(err.Error(), err)
                                return
                        }</span>
                        <span class="cov0" title="0">if err := r.prePatchReboot(); err != nil </span><span class="cov0" title="0">{
                                r.handleErrorState(fmt.Sprintf("Error running prePatchReboot: %v", err), err)
                                return
                        }</span>
                        <span class="cov0" title="0">if r.Job.GetPatchConfig().GetPreStep() != nil </span><span class="cov0" title="0">{
                                if err := r.reportContinuingState(osconfigpb.Instance_RUNNING_PRE_PATCH_STEP); err != nil </span><span class="cov0" title="0">{
                                        r.handleErrorState(err.Error(), err)
                                        return
                                }</span>
                                <span class="cov0" title="0">if err := r.prePatchStep(); err != nil </span><span class="cov0" title="0">{
                                        r.handleErrorState(fmt.Sprintf("Error running pre-patch step: %v", err), err)
                                        return
                                }</span>
                        }
                case patching:<span class="cov0" title="0">
                        if err := r.reportContinuingState(osconfigpb.Instance_APPLYING_PATCHES); err != nil </span><span class="cov0" title="0">{
                                r.handleErrorState(err.Error(), err)
                                return
                        }</span>
                        <span class="cov0" title="0">if r.Job.DryRun </span><span class="cov0" title="0">{
                                r.infof("Dry run - No updates applied for patch job '%s'", r.Job.GetPatchJob())
                        }</span> else<span class="cov0" title="0"> {
                                if err := r.runUpdates(); err != nil </span><span class="cov0" title="0">{
                                        r.handleErrorState(fmt.Sprintf("Failed to apply patches: %v", err), err)
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">if err := r.postPatchReboot(); err != nil </span><span class="cov0" title="0">{
                                r.handleErrorState(fmt.Sprintf("Error running postPatchReboot: %v", err), err)
                                return
                        }</span>
                        // We have not rebooted so patching is complete.
                        <span class="cov0" title="0">if err := r.setStep(postPatch); err != nil </span><span class="cov0" title="0">{
                                r.reportFailedState(fmt.Sprintf("Error saving agent step: %v", err))
                        }</span>
                case postPatch:<span class="cov0" title="0">
                        isRebootRequired, err := r.systemRebootRequired()
                        if err != nil </span><span class="cov0" title="0">{
                                r.reportFailedState(fmt.Sprintf("Error checking if system reboot is required: %v", err))
                                return
                        }</span>
                        <span class="cov0" title="0">if r.Job.GetPatchConfig().GetPostStep() != nil </span><span class="cov0" title="0">{
                                if err := r.reportContinuingState(osconfigpb.Instance_RUNNING_POST_PATCH_STEP); err != nil </span><span class="cov0" title="0">{
                                        r.handleErrorState(err.Error(), err)
                                        return
                                }</span>
                                <span class="cov0" title="0">if err := r.postPatchStep(); err != nil </span><span class="cov0" title="0">{
                                        r.handleErrorState(fmt.Sprintf("Error running post-patch step: %v", err), err)
                                        return
                                }</span>
                        }

                        <span class="cov0" title="0">finalState := osconfigpb.Instance_SUCCEEDED
                        if isRebootRequired </span><span class="cov0" title="0">{
                                finalState = osconfigpb.Instance_SUCCEEDED_REBOOT_REQUIRED
                        }</span>

                        <span class="cov0" title="0">if err := r.reportPatchDetails(finalState, 0, ""); err != nil </span><span class="cov0" title="0">{
                                r.errorf("Failed to report state %s: %v", finalState, err)
                                return
                        }</span>
                        <span class="cov0" title="0">r.infof("Successfully completed patchJob %s", r.Job.GetPatchJob())
                        return</span>
                }
        }
}

func ackPatch(ctx context.Context, patchJobName string) <span class="cov0" title="0">{
        // Notify the server if we haven't yet. If we've already been notified about this Job,
        // the server may have inadvertently notified us twice (at least once deliver) so we
        // can ignore it.
        if liveState.alreadyAckedJob(patchJobName) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">r := &amp;patchRun{
                ctx:       ctx,
                Job:       &amp;patchJob{&amp;osconfigpb.ReportPatchJobInstanceDetailsResponse{PatchJob: patchJobName}},
                LogLabels: map[string]string{"patch_job": patchJobName, "instance_name": config.Name(), "agent_version": config.Version()},
        }
        liveState.addPatchRun(r)
        if err := r.createClient(); err != nil </span><span class="cov0" title="0">{
                r.errorf("Error creating osconfig client: %v", err)
                r.complete()
                return
        }</span>
        <span class="cov0" title="0">if err := r.reportPatchDetails(osconfigpb.Instance_ACKED, 0, ""); err != nil </span><span class="cov0" title="0">{
                r.errorf("reportPatchDetails Error: %v", err)
                r.complete()
                return
        }</span>
        <span class="cov0" title="0">r.setStep(prePatch)
        go tasker.Enqueue("Run patch", r.runPatch)</span>
}

// retry tries to retry f for no more than maxRetryTime.
func retry(maxRetryTime time.Duration, desc string, logF func(string, ...interface{}), f func() error) error <span class="cov0" title="0">{
        rnd := rand.New(rand.NewSource(time.Now().UnixNano()))
        var tot time.Duration
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                err := f()
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Always increasing with some jitter, longest wait will be 5min.
                <span class="cov0" title="0">nf := math.Min(float64(i)*float64(i)+float64(rnd.Intn(i)), 300)
                ns := time.Duration(int(nf)) * time.Second
                tot += ns
                if tot &gt; maxRetryTime </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">logF("Error %s, attempt %d, retrying in %s: %v", desc, i, ns, err)
                time.Sleep(ns)</span>
        }
}

// reportPatchDetails tries to report patch details for 35m.
func (r *patchRun) reportPatchDetails(patchState osconfigpb.Instance_PatchState, attemptCount int64, failureReason string) error <span class="cov0" title="0">{
        var retErr error
        err := retry(2100*time.Second, "reporting patch details", r.debugf, func() error </span><span class="cov0" title="0">{
                // This can't be cached.
                identityToken, err := metadata.Get(config.IdentityTokenPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">request := &amp;osconfigpb.ReportPatchJobInstanceDetailsRequest{
                        Resource:         config.Instance(),
                        InstanceSystemId: config.ID(),
                        PatchJob:         r.Job.GetPatchJob(),
                        InstanceIdToken:  identityToken,
                        State:            patchState,
                        AttemptCount:     attemptCount,
                        FailureReason:    failureReason,
                }
                r.debugf("Reporting patch details request:\n%s", common.PrettyFmt(request))

                res, err := r.client.ReportPatchJobInstanceDetails(r.ctx, request)
                if err != nil </span><span class="cov0" title="0">{
                        if s, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                                err := fmt.Errorf("code: %q, message: %q, details: %q", s.Code(), s.Message(), s.Details())
                                switch s.Code() </span>{
                                // Errors we should retry.
                                case codes.DeadlineExceeded, codes.Unavailable, codes.Aborted, codes.Internal, codes.ResourceExhausted:<span class="cov0" title="0">
                                        return err</span>
                                default:<span class="cov0" title="0">
                                        retErr = err
                                        return nil</span>
                                }
                        }
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">r.debugf("Reporting patch details response:\n%s", common.PrettyFmt(res))
                r.Job.ReportPatchJobInstanceDetailsResponse = res
                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reporting patch details: %v", err)
        }</span>
        <span class="cov0" title="0">if retErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reporting patch details: %v", retErr)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *patchRun) prePatchStep() error <span class="cov0" title="0">{
        r.debugf("Running pre-patch step.")
        return r.execPreStep()
}</span>

func (r *patchRun) postPatchStep() error <span class="cov0" title="0">{
        r.debugf("Running post-patch step.")
        return r.execPostStep()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">//  Copyright 2018 Google Inc. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ospatch

import (
        "encoding/json"
        "io/ioutil"
        "os"
        "path/filepath"
        "sync"

        "github.com/GoogleCloudPlatform/osconfig/config"
)

var liveState state

const pastJobsNum = 10

type state struct {
        PatchRuns []*patchRun `json:",omitempty"`
        PastJobs  []string    `json:",omitempty"`

        sync.RWMutex `json:"-"`
}

func (s *state) jobComplete(job string) <span class="cov8" title="1">{
        s.Lock()
        defer s.Unlock()
        s.PastJobs = append(s.PastJobs, job)
        if len(s.PastJobs) &gt; pastJobsNum </span><span class="cov8" title="1">{
                s.PastJobs = s.PastJobs[len(s.PastJobs)-pastJobsNum : len(s.PastJobs)]
        }</span>
}

func (s *state) addPatchRun(pr *patchRun) <span class="cov8" title="1">{
        s.Lock()
        defer s.Unlock()
        (*s).PatchRuns = append((*s).PatchRuns, pr)
}</span>

func (s *state) removePatchRun(pr *patchRun) <span class="cov8" title="1">{
        s.Lock()
        defer s.Unlock()

        for i, r := range s.PatchRuns </span><span class="cov8" title="1">{
                if r.Job.PatchJob == pr.Job.PatchJob </span><span class="cov8" title="1">{
                        copy(s.PatchRuns[i:], s.PatchRuns[i+1:])
                        s.PatchRuns[len(s.PatchRuns)-1] = nil
                        s.PatchRuns = s.PatchRuns[:len(s.PatchRuns)-1]
                        return
                }</span>
        }
}

func (s *state) alreadyAckedJob(job string) bool <span class="cov8" title="1">{
        s.RLock()
        defer s.RUnlock()
        for _, r := range s.PatchRuns </span><span class="cov8" title="1">{
                if r.Job.PatchJob == job </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">for _, j := range s.PastJobs </span><span class="cov8" title="1">{
                if j == job </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (s *state) save(path string) error <span class="cov8" title="1">{
        s.RLock()
        defer s.RUnlock()

        if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if s == nil </span><span class="cov0" title="0">{
                return writeFile(path, []byte("{}"))
        }</span>

        <span class="cov8" title="1">d, err := json.Marshal(s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return writeFile(path, d)</span>
}

func saveState() error <span class="cov0" title="0">{
        return liveState.save(config.PatchStateFile())
}</span>

func loadState(path string) error <span class="cov8" title="1">{
        liveState.Lock()
        defer liveState.Unlock()

        d, err := ioutil.ReadFile(path)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return json.Unmarshal(d, &amp;liveState)</span>
}

func writeFile(path string, data []byte) error <span class="cov8" title="1">{
        // Write state to a temporary file first.
        tmp, err := ioutil.TempFile(filepath.Dir(path), "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">newStateFile := tmp.Name()

        if _, err = tmp.Write(data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tmp.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Move the new temp file to the live path.
        <span class="cov8" title="1">return os.Rename(newStateFile, path)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">//  Copyright 2019 Google Inc. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ospatch

import (
        "os/exec"

        "github.com/GoogleCloudPlatform/guest-logging-go/logger"
)

var defaultRunner = func(cmd *exec.Cmd) ([]byte, error) <span class="cov0" title="0">{
        logger.Debugf("Running %q with args %q\n", cmd.Path, cmd.Args[1:])
        out, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                logger.Debugf("error running %q with args %q: %v, stdout: %s", cmd.Path, cmd.Args, err, out)
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

var patchRunRunner = func(r *patchRun) func(cmd *exec.Cmd) ([]byte, error) <span class="cov0" title="0">{
        return func(cmd *exec.Cmd) ([]byte, error) </span><span class="cov0" title="0">{
                r.debugf("Running %q with args %q\n", cmd.Path, cmd.Args[1:])
                out, err := cmd.CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        r.debugf("error running %q with args %q: %v, stdout: %s", cmd.Path, cmd.Args, err, out)
                        return nil, err
                }</span>
                <span class="cov0" title="0">return out, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">//  Copyright 2019 Google Inc. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

//+build !test

package ospatch

import (
        "bytes"
        "fmt"
        "os"
        "os/exec"
        "syscall"
        "time"

        "github.com/GoogleCloudPlatform/guest-logging-go/logger"
        "github.com/GoogleCloudPlatform/osconfig/common"
)

const (
        systemctl = "/bin/systemctl"
        reboot    = "/bin/reboot"
        shutdown  = "/bin/shutdown"
)

// disableAutoUpdates disables system auto updates.
func disableAutoUpdates() <span class="cov0" title="0">{
        // yum-cron on el systems
        if _, err := os.Stat("/usr/lib/systemd/system/yum-cron.service"); err == nil </span><span class="cov0" title="0">{
                out, err := exec.Command(systemctl, "is-enabled", "yum-cron.service").CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        if eerr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                                // Error code of 1 indicates disabled.
                                if eerr.ExitCode() == 1 </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">logger.Errorf("Error checking status of yum-cron, error: %v, out: %s", err, out)</span>
                }

                <span class="cov0" title="0">logger.Debugf("Disabling yum-cron")
                out, err = exec.Command(systemctl, "stop", "yum-cron.service").CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error stopping yum-cron, error: %v, out: %s", err, out)
                }</span>
                <span class="cov0" title="0">out, err = exec.Command(systemctl, "disable", "yum-cron.service").CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error disabling yum-cron, error: %v, out: %s", err, out)
                }</span>
        } else<span class="cov0" title="0"> if _, err := os.Stat("/usr/sbin/yum-cron"); err == nil </span><span class="cov0" title="0">{
                out, err := exec.Command("/sbin/chkconfig", "yum-cron").CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error checking status of yum-cron, error: %v, out: %s", err, out)
                }</span>
                <span class="cov0" title="0">if bytes.Contains(out, []byte("disabled")) </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">logger.Debugf("Disabling yum-cron")
                out, err = exec.Command("/sbin/chkconfig", "yum-cron", "off").CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error disabling yum-cron, error: %v, out: %s", err, out)
                }</span>
        }

        // dnf-automatic on el8 systems
        <span class="cov0" title="0">if _, err := os.Stat("/usr/lib/systemd/system/dnf-automatic.timer"); err == nil </span><span class="cov0" title="0">{
                out, err := exec.Command(systemctl, "list-timers", "dnf-automatic.timer").CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error checking status of dnf-automatic, error: %v, out: %s", err, out)
                }</span>
                <span class="cov0" title="0">if bytes.Contains(out, []byte("0 timers listed")) </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">logger.Debugf("Disabling dnf-automatic")
                out, err = exec.Command(systemctl, "stop", "dnf-automatic.timer").CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error stopping dnf-automatic, error: %v, out: %s", err, out)
                }</span>
                <span class="cov0" title="0">out, err = exec.Command(systemctl, "disable", "dnf-automatic.timer").CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error disabling dnf-automatic, error: %v, out: %s", err, out)
                }</span>
        }

        // apt unattended-upgrades
        // TODO: Removing the package is a bit overkill, look into just managing
        // the configs, this is probably best done by looking through
        // /etc/apt/apt.conf.d/ and setting APT::Periodic::Unattended-Upgrade to 0.
        <span class="cov0" title="0">if _, err := os.Stat("/usr/bin/unattended-upgrades"); err == nil </span><span class="cov0" title="0">{
                logger.Debugf("Removing unattended-upgrades package")
                f := func() error </span><span class="cov0" title="0">{
                        out, err := exec.Command(aptGet, "remove", "-y", "unattended-upgrades").CombinedOutput()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%v, out: %s", err, out)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">if err := retry(1*time.Minute, "removing unattended-upgrades package", logger.Debugf, f); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error removing unattended-upgrades, error: %v", err)
                }</span>
        }
}

func rebootSystem() error <span class="cov0" title="0">{
        // Start with systemctl and work down a list of reboot methods.
        if e := common.Exists(systemctl); e </span><span class="cov0" title="0">{
                return exec.Command(systemctl, "reboot").Start()
        }</span>
        <span class="cov0" title="0">if e := common.Exists(reboot); e </span><span class="cov0" title="0">{
                return exec.Command(reboot).Run()
        }</span>
        <span class="cov0" title="0">if e := common.Exists(shutdown); e </span><span class="cov0" title="0">{
                return exec.Command(shutdown, "-r", "-t", "0").Run()
        }</span>

        // Fall back to reboot(2) system call
        <span class="cov0" title="0">syscall.Sync()
        return syscall.Reboot(syscall.LINUX_REBOOT_CMD_RESTART)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">//  Copyright 2019 Google Inc. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ospatch

import (
        "bufio"
        "bytes"
        "fmt"
        "os"
        "os/exec"
        "strconv"
)

const (
        rpmquery = "/usr/bin/rpmquery"
)

func getBtime(stat string) (int, error) <span class="cov8" title="1">{
        f, err := os.Open(stat)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("error opening %s: %v", stat, err)
        }</span>
        <span class="cov8" title="1">defer f.Close()

        var btime int
        scnr := bufio.NewScanner(f)
        for scnr.Scan() </span><span class="cov8" title="1">{
                if bytes.HasPrefix(scnr.Bytes(), []byte("btime")) </span><span class="cov8" title="1">{
                        split := bytes.SplitN(scnr.Bytes(), []byte(" "), 2)
                        if len(split) != 2 </span><span class="cov8" title="1">{
                                return 0, fmt.Errorf("error parsing btime from %s: %q", stat, scnr.Text())
                        }</span>
                        <span class="cov8" title="1">btime, err = strconv.Atoi(string(bytes.TrimSpace(split[1])))
                        if err != nil </span><span class="cov8" title="1">{
                                return 0, fmt.Errorf("error parsing btime: %v", err)
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }
        <span class="cov8" title="1">if err := scnr.Err(); err != nil &amp;&amp; btime == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("error scanning %s: %v", stat, err)
        }</span>
        <span class="cov8" title="1">if btime == 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("could not find btime in %s", stat)
        }</span>

        <span class="cov8" title="1">return btime, nil</span>
}

func rpmRebootRequired(pkgs []byte, btime int) bool <span class="cov8" title="1">{
        // Scanning this output is best effort, false negatives are much prefered
        // to false positives, and keeping this as simple as possible is
        // beneficial.
        scnr := bufio.NewScanner(bytes.NewReader(pkgs))
        for scnr.Scan() </span><span class="cov8" title="1">{
                itime, err := strconv.Atoi(scnr.Text())
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if itime &gt; btime </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>

}

// rpmReboot returns whether an rpm based system should reboot in order to
// finish installing updates.
// To get this signal we look at a set of well known packages and whether
// install time &gt; system boot time. This list is not meant to be exhastive,
// just to provide a signal when core system packages are updated.
func rpmReboot() (bool, error) <span class="cov0" title="0">{
        provides := []string{
                // Common packages.
                "kernel", "glibc", "gnutls",
                // EL packages.
                "linux-firmware", "openssl-libs", "dbus",
                // Suse packages.
                "kernel-firmware", "libopenssl1_1", "libopenssl1_0_0", "dbus-1",
        }
        args := append([]string{"--queryformat", "%{INSTALLTIME}\n", "--whatprovides"}, provides...)
        out, err := exec.Command(rpmquery, args...).Output()
        if err != nil </span><span class="cov0" title="0">{
                // We don't care about return codes as we know some of these packages won't be installed.
                if _, ok := err.(*exec.ExitError); !ok </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("error running %s: %v", rpmquery, err)
                }</span>
        }

        <span class="cov0" title="0">btime, err := getBtime("/proc/stat")
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return rpmRebootRequired(out, btime), nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">//  Copyright 2018 Google Inc. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

//+build !test

package ospatch

import (
        "errors"
        "io/ioutil"
        "os"
        "strings"
        "time"

        "github.com/GoogleCloudPlatform/osconfig/common"
        "github.com/GoogleCloudPlatform/osconfig/inventory/packages"

        osconfigpb "github.com/GoogleCloudPlatform/osconfig/_internal/gapi-cloud-osconfig-go/google.golang.org/genproto/googleapis/cloud/osconfig/v1alpha2"
)

func (r *patchRun) systemRebootRequired() (bool, error) <span class="cov0" title="0">{
        if packages.AptExists </span><span class="cov0" title="0">{
                r.debugf("Checking if reboot required by looking at /var/run/reboot-required.")
                data, err := ioutil.ReadFile("/var/run/reboot-required")
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        r.debugf("/var/run/reboot-required does not exist, indicating no reboot is required.")
                        return false, nil
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">r.debugf("/var/run/reboot-required exists indicating a reboot is required, content:\n%s", string(data))
                return true, nil</span>
        }
        <span class="cov0" title="0">if ok := common.Exists(rpmquery); ok </span><span class="cov0" title="0">{
                r.debugf("Checking if reboot required by querying rpm database.")
                return rpmReboot()
        }</span>

        <span class="cov0" title="0">return false, errors.New("no recognized package manager installed, can't determine if reboot is required")</span>
}

func (r *patchRun) runUpdates() error <span class="cov0" title="0">{
        var errs []string
        const retryPeriod = 3 * time.Minute
        if packages.AptExists </span><span class="cov0" title="0">{
                opts := []AptGetUpgradeOption{AptGetUpgradeRunner(patchRunRunner(r))}
                switch r.Job.GetPatchConfig().GetApt().GetType() </span>{
                case osconfigpb.AptSettings_DIST:<span class="cov0" title="0">
                        opts = append(opts, AptGetUpgradeType(AptGetDistUpgrade))</span>
                }
                <span class="cov0" title="0">r.debugf("Installing APT package updates.")
                if err := retry(retryPeriod, "installing APT package updates", r.debugf, func() error </span><span class="cov0" title="0">{ return RunAptGetUpgrade(opts...) }</span>); err != nil <span class="cov0" title="0">{
                        errs = append(errs, err.Error())
                }</span>
        }
        <span class="cov0" title="0">if packages.YumExists </span><span class="cov0" title="0">{
                opts := []YumUpdateOption{
                        YumUpdateRunner(patchRunRunner(r)),
                        YumUpdateSecurity(r.Job.GetPatchConfig().GetYum().GetSecurity()),
                        YumUpdateMinimal(r.Job.GetPatchConfig().GetYum().GetMinimal()),
                        YumUpdateExcludes(r.Job.GetPatchConfig().GetYum().GetExcludes()),
                }
                r.debugf("Installing YUM package updates.")
                if err := retry(retryPeriod, "installing YUM package updates", r.debugf, func() error </span><span class="cov0" title="0">{ return RunYumUpdate(opts...) }</span>); err != nil <span class="cov0" title="0">{
                        errs = append(errs, err.Error())
                }</span>
        }
        <span class="cov0" title="0">if packages.ZypperExists </span><span class="cov0" title="0">{
                opts := []ZypperPatchOption{
                        ZypperPatchRunner(patchRunRunner(r)),
                        ZypperPatchCategories(r.Job.GetPatchConfig().GetZypper().GetCategories()),
                        ZypperPatchSeverities(r.Job.GetPatchConfig().GetZypper().GetSeverities()),
                        ZypperUpdateWithUpdate(r.Job.GetPatchConfig().GetZypper().GetWithUpdate()),
                        ZypperUpdateWithOptional(r.Job.GetPatchConfig().GetZypper().GetWithOptional()),
                }
                r.debugf("Installing Zypper package updates.")
                if err := retry(retryPeriod, "installing Zypper package updates", r.debugf, func() error </span><span class="cov0" title="0">{ return RunZypperPatch(opts...) }</span>); err != nil <span class="cov0" title="0">{
                        errs = append(errs, err.Error())
                }</span>
        }
        <span class="cov0" title="0">if errs == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return errors.New(strings.Join(errs, ",\n"))</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">//  Copyright 2019 Google Inc. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ospatch

import (
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net"
        "net/http"
        "net/url"
        "strings"
        "time"

        "github.com/GoogleCloudPlatform/guest-logging-go/logger"
)

const (
        defaultEtag = "NONE"
)

var (
        metadataURL         = "http://metadata.google.internal/computeMetadata/v1/instance/attributes/?recursive=true&amp;wait_for_change=true&amp;last_etag="
        currentPatchJobName = ""
)

type watchMetadataRet struct {
        attr *attributesJSON
        err  error
}

type attributesJSON struct {
        PatchNotify string `json:"osconfig-patch-notify"`
}

func watchMetadata(c chan watchMetadataRet, etag *string) <span class="cov8" title="1">{
        client := &amp;http.Client{}

        req, err := http.NewRequest("GET", metadataURL+*etag, nil)
        if err != nil </span><span class="cov0" title="0">{
                c &lt;- watchMetadataRet{
                        attr: nil,
                        err:  err,
                }
                return
        }</span>

        <span class="cov8" title="1">req.Header.Add("Metadata-Flavor", "Google")
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                c &lt;- watchMetadataRet{
                        attr: nil,
                        err:  err,
                }
                return
        }</span>
        <span class="cov8" title="1">*etag = resp.Header.Get("etag")

        md, err := ioutil.ReadAll(resp.Body)
        resp.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                c &lt;- watchMetadataRet{
                        attr: nil,
                        err:  err,
                }
                return
        }</span>

        <span class="cov8" title="1">var metadata attributesJSON
        err = json.Unmarshal(md, &amp;metadata)
        c &lt;- watchMetadataRet{
                attr: &amp;metadata,
                err:  err,
        }</span>
}

func formatError(err error) string <span class="cov0" title="0">{
        if urlErr, ok := err.(*url.Error); ok </span><span class="cov0" title="0">{
                if _, ok := urlErr.Err.(*net.DNSError); ok </span><span class="cov0" title="0">{
                        return fmt.Sprintf("DNS error when requesting metadata, check DNS settings and ensure metadata.internal.google is setup in your hosts file.")
                }</span>
                <span class="cov0" title="0">if _, ok := urlErr.Err.(*net.OpError); ok </span><span class="cov0" title="0">{
                        return fmt.Sprintf("Network error when requesting metadata, make sure your instance has an active network and can reach the metadata server.")
                }</span>
        }
        <span class="cov0" title="0">return err.Error()</span>
}

func watcher(ctx context.Context, cancel &lt;-chan struct{}, action func(context.Context, string)) <span class="cov8" title="1">{
        webError := 0
        // We use a pointer so that each loops goroutine can update this.
        // If this was a global var we would have a data race, and puting
        // locks around it is more work than necessary.
        etag := func() *string </span><span class="cov8" title="1">{ e := defaultEtag; return &amp;e }</span>()
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                c := make(chan watchMetadataRet)
                go func(c chan watchMetadataRet, etag *string) </span><span class="cov8" title="1">{
                        watchMetadata(c, etag)
                }</span>(c, etag)

                <span class="cov8" title="1">select </span>{
                case &lt;-cancel:<span class="cov8" title="1">
                        return</span>
                case ret := &lt;-c:<span class="cov8" title="1">
                        if ret.err != nil </span><span class="cov0" title="0">{
                                // Only log the second web error to avoid transient errors and
                                // not to spam the log on network failures.
                                if webError == 1 </span><span class="cov0" title="0">{
                                        logger.Errorf(formatError(ret.err))
                                }</span>
                                <span class="cov0" title="0">webError++
                                time.Sleep(5 * time.Second)
                                continue</span>
                        }

                        <span class="cov8" title="1">patchJobName := strings.Split(ret.attr.PatchNotify, ",")[0]
                        if patchJobName == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">action(ctx, patchJobName)

                        webError = 0</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">//  Copyright 2019 Google Inc. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ospatch

import (
        "os/exec"
)

const yum = "/usr/bin/yum"

var (
        yumUpdateArgs        = []string{"update", "-y"}
        yumUpdateMinimalArgs = []string{"update-minimal", "-y"}
)

type yumUpdateOpts struct {
        security bool
        minimal  bool
        excludes []string
        runner   func(cmd *exec.Cmd) ([]byte, error)
}

// YumUpdateOption is an option for yum update.
type YumUpdateOption func(*yumUpdateOpts)

// YumUpdateSecurity returns a YumUpdateOption that specifies the --security flag should
// be used.
func YumUpdateSecurity(security bool) YumUpdateOption <span class="cov0" title="0">{
        return func(args *yumUpdateOpts) </span><span class="cov0" title="0">{
                args.security = security
        }</span>
}

// YumUpdateMinimal returns a YumUpdateOption that specifies the update-minimal
// command should be used.
func YumUpdateMinimal(minimal bool) YumUpdateOption <span class="cov0" title="0">{
        return func(args *yumUpdateOpts) </span><span class="cov0" title="0">{
                args.minimal = minimal
        }</span>
}

// YumUpdateExcludes returns a YumUpdateOption that specifies what packages to add to
// the --exclude flag.
func YumUpdateExcludes(excludes []string) YumUpdateOption <span class="cov0" title="0">{
        return func(args *yumUpdateOpts) </span><span class="cov0" title="0">{
                args.excludes = excludes
        }</span>
}

// YumUpdateRunner returns a YumUpdateOption that specifies the runner.
func YumUpdateRunner(runner func(cmd *exec.Cmd) ([]byte, error)) YumUpdateOption <span class="cov0" title="0">{
        return func(args *yumUpdateOpts) </span><span class="cov0" title="0">{
                args.runner = runner
        }</span>
}

// RunYumUpdate runs yum update.
func RunYumUpdate(opts ...YumUpdateOption) error <span class="cov0" title="0">{
        yumOpts := &amp;yumUpdateOpts{
                security: false,
                minimal:  false,
                excludes: nil,
                runner:   defaultRunner,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(yumOpts)
        }</span>

        <span class="cov0" title="0">args := yumUpdateArgs
        if yumOpts.minimal </span><span class="cov0" title="0">{
                args = yumUpdateMinimalArgs
        }</span>
        <span class="cov0" title="0">if yumOpts.security </span><span class="cov0" title="0">{
                args = append(args, "--security")
        }</span>
        <span class="cov0" title="0">for _, e := range yumOpts.excludes </span><span class="cov0" title="0">{
                args = append(args, "--exclude="+e)
        }</span>

        <span class="cov0" title="0">if _, err := yumOpts.runner(exec.Command(yum, args...)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">//  Copyright 2019 Google Inc. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ospatch

import (
        "os/exec"
)

const zypper = "/usr/bin/zypper"

var (
        zypperPatchArgs = []string{"patch", "-y"}
)

type zypperPatchOpts struct {
        categories   []string
        severities   []string
        withOptional bool
        withUpdate   bool
        runner       func(cmd *exec.Cmd) ([]byte, error)
}

// ZypperPatchOption is an option for zypper patch.
type ZypperPatchOption func(*zypperPatchOpts)

// ZypperPatchCategories returns a ZypperUpdateOption that specifies what
// categories to add to the --categories flag.
func ZypperPatchCategories(categories []string) ZypperPatchOption <span class="cov0" title="0">{
        return func(args *zypperPatchOpts) </span><span class="cov0" title="0">{
                args.categories = categories
        }</span>
}

// ZypperPatchSeverities returns a ZypperUpdateOption that specifies what
// categories to add to the --categories flag.
func ZypperPatchSeverities(severities []string) ZypperPatchOption <span class="cov0" title="0">{
        return func(args *zypperPatchOpts) </span><span class="cov0" title="0">{
                args.severities = severities
        }</span>
}

// ZypperUpdateWithOptional returns a ZypperUpdateOption that specifies the
// --with-optional flag should be used.
func ZypperUpdateWithOptional(withOptional bool) ZypperPatchOption <span class="cov0" title="0">{
        return func(args *zypperPatchOpts) </span><span class="cov0" title="0">{
                args.withOptional = withOptional
        }</span>
}

// ZypperUpdateWithUpdate returns a ZypperUpdateOption that specifies the
// --with-update flag should be used.
func ZypperUpdateWithUpdate(withUpdate bool) ZypperPatchOption <span class="cov0" title="0">{
        return func(args *zypperPatchOpts) </span><span class="cov0" title="0">{
                args.withUpdate = withUpdate
        }</span>
}

// ZypperPatchRunner returns a ZypperUpdateOption that specifies the runner.
func ZypperPatchRunner(runner func(cmd *exec.Cmd) ([]byte, error)) ZypperPatchOption <span class="cov0" title="0">{
        return func(args *zypperPatchOpts) </span><span class="cov0" title="0">{
                args.runner = runner
        }</span>
}

// RunZypperPatch runs zypper patch.
func RunZypperPatch(opts ...ZypperPatchOption) error <span class="cov0" title="0">{
        zOpts := &amp;zypperPatchOpts{
                runner: defaultRunner,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(zOpts)
        }</span>

        <span class="cov0" title="0">args := zypperPatchArgs
        if zOpts.withOptional </span><span class="cov0" title="0">{
                args = append(args, "--with-optional")
        }</span>
        <span class="cov0" title="0">if zOpts.withUpdate </span><span class="cov0" title="0">{
                args = append(args, "--with-update")
        }</span>
        <span class="cov0" title="0">for _, c := range zOpts.categories </span><span class="cov0" title="0">{
                args = append(args, "--category="+c)
        }</span>
        <span class="cov0" title="0">for _, s := range zOpts.severities </span><span class="cov0" title="0">{
                args = append(args, "--severity="+s)
        }</span>

        <span class="cov0" title="0">if _, err := zOpts.runner(exec.Command(zypper, args...)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
